{"version":3,"sources":["../../src/metadata/IndexMetadata.ts"],"names":[],"mappings":"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","file":"IndexMetadata.js","sourcesContent":["import {EntityMetadata} from \"./EntityMetadata\";\nimport {IndexMetadataArgs} from \"../metadata-args/IndexMetadataArgs\";\n\n/**\n * Index metadata contains all information about table's index.\n */\nexport class IndexMetadata {\n\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the class to which this index is applied.\n     */\n    entityMetadata: EntityMetadata;\n\n    // ---------------------------------------------------------------------\n    // Readonly Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Indicates if this index must be unique.\n     */\n    readonly isUnique: boolean;\n\n    /**\n     * Target class to which metadata is applied.\n     */\n    readonly target?: Function|string;\n\n    // ---------------------------------------------------------------------\n    // Private Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Composite index name.\n     */\n    private readonly _name: string|undefined;\n\n    /**\n     * Columns combination to be used as index.\n     */\n    private readonly _columns: ((object?: any) => (any[]|{ [key: string]: number }))|string[];\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(args: IndexMetadataArgs) {\n        this.target = args.target;\n        this._columns = args.columns;\n        this._name = args.name;\n        this.isUnique = args.unique;\n    }\n\n    // ---------------------------------------------------------------------\n    // Accessors\n    // ---------------------------------------------------------------------\n\n    /**\n     * Gets index's name.\n     */\n    get name() {\n        return this.entityMetadata.namingStrategy.indexName(this._name, this.entityMetadata.table.name, this.columns);\n    }\n\n    /**\n     * Gets the table name on which index is applied.\n     */\n    get tableName() {\n        return this.entityMetadata.table.name;\n    }\n\n    /**\n     * Gets the column names which are in this index.\n     */\n    get columns(): string[] {\n\n        // if columns already an array of string then simply return it\n        let columnPropertyNames: string[] = [];\n        if (this._columns instanceof Array) {\n            columnPropertyNames = this._columns;\n        } else {\n            // if columns is a function that returns array of field names then execute it and get columns names from it\n            const propertiesMap = this.entityMetadata.createPropertiesMap();\n            const columnsFnResult = this._columns(propertiesMap);\n            const columnsNamesFromFnResult = columnsFnResult instanceof Array ? columnsFnResult : Object.keys(columnsFnResult);\n            columnPropertyNames = columnsNamesFromFnResult.map((i: any) => String(i));\n        }\n\n        const columns = this.entityMetadata.columns.filter(column => columnPropertyNames.indexOf(column.propertyName) !== -1);\n        const missingColumnNames = columnPropertyNames.filter(columnPropertyName => !this.entityMetadata.columns.find(column => column.propertyName === columnPropertyName));\n        if (missingColumnNames.length > 0) { // todo: better to extract all validation into single place is possible\n            // console.log(this.entityMetadata.columns);\n            throw new Error(`Index ${this._name ? \"\\\"\" + this._name + \"\\\" \" : \"\"}contains columns that are missing in the entity: ` + missingColumnNames.join(\", \"));\n        }\n\n        return columns.map(column => column.fullName);\n    }\n\n    /**\n     * Builds columns as a map of values where column name is key of object and value is a value provided by\n     * function or default value given to this function.\n     */\n    buildColumnsAsMap(defaultValue = 0): { [key: string]: number } {\n\n        const map: { [key: string]: number } = {};\n\n        // if columns already an array of string then simply create a map from it\n        if (this._columns instanceof Array) {\n            this._columns.forEach(columnName => map[columnName] = defaultValue);\n\n        } else {\n            // if columns is a function that returns array of field names then execute it and get columns names from it\n            const propertiesMap = this.entityMetadata.createPropertiesMap();\n            const columnsFnResult = this._columns(propertiesMap);\n            if (columnsFnResult instanceof Array) {\n                columnsFnResult.forEach(columnName => map[columnName] = defaultValue);\n            } else {\n                Object.keys(columnsFnResult).forEach(columnName => map[columnName] = columnsFnResult[columnName]);\n            }\n        }\n\n        // replace each propertyNames with column names\n        return Object.keys(map).reduce((updatedMap, key) => {\n            const column = this.entityMetadata.columns.find(column => column.propertyName === key);\n            if (!column)\n                throw new Error(`Index ${this._name ? \"\\\"\" + this._name + \"\\\" \" : \"\"}contains columns that are missing in the entity: ${key}`);\n\n            updatedMap[column.name] = map[key];\n            return updatedMap;\n        }, {} as { [key: string]: number });\n    }\n\n}"],"sourceRoot":".."}